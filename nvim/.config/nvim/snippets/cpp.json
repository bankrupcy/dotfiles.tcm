{
  "CP Minimal Template": {
    "prefix": "<template",
    "body": [
      "#include \"bits/stdc++.h\"",
      "using namespace std;",
      "",
      "int main() {",
      "    ios_base::sync_with_stdio(0);",
      "    cin.tie(0);",
      "",
      "    $0",
      "}"
    ]
  },
  "CP Gen Template": {
    "prefix": "<gen",
    "body": [
      "#include \"bits/stdc++.h\"",
      "using namespace std;",
      "",
      "long long rand(long long a, long long b) {",
      "    return a + rand() % (b - a + 1);",
      "}",
      "",
      "int main(int argc, char *argv[]) {",
      "    srand(atoi(argv[1]));",
      "}"
    ]
  },
  "Binary Index Tree (Fenwick Tree)": {
    "prefix": "<bit",
    "body": [
      "template <class T>",
      "struct BIT {",
      "    vector<T> v;",
      "    int n;",
      "    void init(int _n) {",
      "        n = _n;",
      "        v.resize(n + 1);",
      "    }",
      "    void add(int p, T val) {",
      "        for (; p <= n; p += p & -p) v[p] += val;",
      "    }",
      "    T sum(int l, int r) {",
      "        return sum(r) - sum(l - 1);",
      "    }",
      "    T sum(int k) {",
      "        T sum = 0;",
      "        for (; k; k -= k & -k) sum += v[k];",
      "        return sum;",
      "    }",
      "};"
    ]
  },
  "Disjoint Set Union": {
    "prefix": "<dsu",
    "body": [
      "struct DSU {",
      "    vector<int> v;",
      "    void init(int n) { v = vector<int>(n, -1); }",
      "    int sameSet(int a, int b) { return get(a) == get(b); }",
      "    int get(int a) { return v[a] < 0 ? a : v[a] = get(v[a]); }",
      "    int size(int a) { return -v[get(a)]; }",
      "    int unite(int a, int b) {",
      "        a = get(a), b = get(b);",
      "        if (a == b) return false;",
      "        if (v[a] > v[b]) swap(a, b);",
      "        v[a] += v[b];",
      "        v[b] = a;",
      "        return true;",
      "    }",
      "};"
    ]
  },
  "Segment Tree": {
    "prefix": "<seg",
    "body": [
      "template <class T>",
      "struct Seg {",
      "    const T ID = ${1:initial_value};",
      "    T cmb(T a, T b) { return ${0:function}; }",
      "    int N;",
      "    vector<T> seg;",
      "    void init(int _N) {",
      "        for (N = 1; N < _N;) N *= 2;",
      "        seg.assign(2*N, ID);",
      "    }",
      "    void pull(int p) { seg[p] = cmb(seg[2 * p], seg[2 * p + 1]); }",
      "    void upd(int p, T val) {",
      "        seg[p += N] = val;",
      "        for (p /= 2; p; p /= 2) pull(p);",
      "    }",
      "    T query(int l, int r) {",
      "        T ra = ID, rb = ID;",
      "        for (l += N, r += N + 1; l < r; l /= 2, r /= 2) {",
      "            if (l & 1) ra = cmb(ra, seg[l++]);",
      "            if (r & 1) rb = cmb(rb, seg[--r]);",
      "        }",
      "        return cmb(ra, rb);",
      "    }",
      "};"
    ]
  },
  "Lazy Segment Tree": {
    "prefix": "<lazyseg",
    "body": [
      "template <class T, int N>",
      "struct LazySeg {",
      "    static_assert(__builtin_popcount(N) == 1);",
      "    const T ID = ${1:initial_value};",
      "    T cmb(T a, T b) { return ${0:function}; }",
      "    T seg[2 * N], lazy[2 * N];",
      "    LazySeg() {",
      "        for (int i = 0; i < 2 * N; i++)",
      "            seg[i] = lazy[i] = ID;",
      "    }",
      "    void push(int p, int L, int R) {",
      "        seg[p] += (R - L + 1) * lazy[p];",
      "        if (L != R) {",
      "            lazy[2 * p] += lazy[p];",
      "            lazy[2 * p + 1] += lazy[p];",
      "        }",
      "        lazy[p] = 0;",
      "    }",
      "    void pull(int p) { seg[p] = cmb(seg[2 * p], seg[2 * p + 1]); }",
      "    void build() {",
      "        for (int i = N - 1; i >= 1; i--)",
      "            pull(i);",
      "    }",
      "    void upd(int lo, int hi, T inc, int p = 1, int L = 0, int R = N - 1) {",
      "        push(p, L, R);",
      "        if (lo > R || L > hi) return;",
      "        if (lo <= L && R <= hi) {",
      "            lazy[p] = inc;",
      "            push(p, L, R);",
      "            return;",
      "        }",
      "        int M = (L + R) / 2;",
      "        upd(lo, hi, inc, 2 * p, L, M);",
      "        upd(lo, hi, inc, 2 * p + 1, M + 1, R);",
      "        pull(p);",
      "    }",
      "    T query(int lo, int hi, int p = 1, int L = 0, int R = N - 1) {",
      "        push(p, L, R);",
      "        if (lo > R || L > hi) return ID;",
      "        if (lo <= L && R <= hi) return seg[p];",
      "        int M = (L + R) / 2;",
      "        return cmb(query(lo, hi, 2 * p, L, M), query(lo, hi, 2 * p + 1, M + 1, R));",
      "    }",
      "};"
    ]
  },
  "Indexed Set": {
    "prefix": "<indset",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "using namespace __gnu_pbds;",
      "",
      "template <class T>",
      "using IndSet = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;"
    ]
  },
  "Hashing String": {
    "prefix": "<hash",
    "body": [
      "class HashedString {",
      "   private:",
      "    static const long long MOD = (1ll << 61) - 1;",
      "    static const long long BASE;",
      "    static vector<long long> p;",
      "    vector<long long> h;",
      "",
      "    __int128 mul(long long a, long long b) { return (__int128)a * b; }",
      "    long long mod_mul(long long a, long long b) { return mul(a, b) % MOD; }",
      "",
      "   public:",
      "    HashedString(string s) : h(s.length() + 1) {",
      "        h[0] = 0;",
      "        for (int i = 0; s[i]; i++) {",
      "            h[i + 1] = (mul(h[i], BASE) + s[i] - 'a' + 1) % MOD;",
      "            p.push_back(mod_mul(p[i], BASE));",
      "        }",
      "    }",
      "",
      "    long long getHash(int l, int r) {",
      "        long long ans = (h[r + 1] - mod_mul(h[l], p[r - l + 1])) % MOD;",
      "        return ans < 0 ? ans + MOD : ans;",
      "    }",
      "};",
      "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());",
      "vector<long long> HashedString::p = {1};",
      "const long long HashedString::BASE = uniform_int_distribution<long long>(0, MOD - 1)(rng);"
    ]
  }
}
