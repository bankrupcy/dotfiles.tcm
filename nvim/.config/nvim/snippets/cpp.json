{
  "CP Minimal Template": {
    "prefix": "<template",
    "body": [
      "#include \"bits/stdc++.h\"",
      "using namespace std;",
      "",
      "int main() {",
      "    ios_base::sync_with_stdio(0);",
      "    cin.tie(0);",
      "",
      "    $0",
      "}"
    ]
  },
  "Segment Tree": {
    "prefix": "<seg",
    "body": [
      "template <class T>",
      "struct Seg {",
      "    const T ID = ${1:initial_value};",
      "    T cmb(T a, T b) { return ${0:function}; }",
      "    int N;",
      "    vector<T> seg;",
      "    void init(int _N) {",
      "        for (N = 1; N < _N;) N *= 2;",
      "        seg.assign(2*N, ID);",
      "    }",
      "    void pull(int p) { seg[p] = cmb(seg[2 * p], seg[2 * p + 1]); }",
      "    void upd(int p, int val) {",
      "        seg[p += N] = val;",
      "        for (p /= 2; p; p /= 2) pull(p);",
      "    }",
      "    T query(int l, int r) {",
      "        T ra = ID, rb = ID;",
      "        for (l += N, r += N + 1; l < r; l /= 2, r /= 2) {",
      "            if (l & 1) ra = cmb(ra, seg[l++]);",
      "            if (r & 1) rb = cmb(rb, seg[--r]);",
      "        }",
      "        return cmb(ra, rb);",
      "    }",
      "};"
    ]
  },
  "Lazy Segment Tree": {
    "prefix": "<lazyseg",
    "body": [
      "template <class T, int N>",
      "struct LazySeg {",
      "    static_assert(__builtin_popcount(N) == 1);",
      "    const T ID = ${1:initial_value};",
      "    T cmb(T a, T b) { return ${0:function}; }",
      "    T seg[2 * N], lazy[2 * N];",
      "    LazySeg() {",
      "        for (int i = 0; i < 2 * N; i++)",
      "            seg[i] = lazy[i] = ID;",
      "    }",
      "    void push(int p, int L, int R) {",
      "        seg[p] += (R - L + 1) * lazy[p];",
      "        if (L != R) {",
      "            lazy[2 * p] += lazy[p];",
      "            lazy[2 * p + 1] += lazy[p];",
      "        }",
      "        lazy[p] = 0;",
      "    }",
      "    void pull(int p) { seg[p] = cmb(seg[2 * p], seg[2 * p + 1]); }",
      "    void build() {",
      "        for (int i = N - 1; i >= 1; i--)",
      "            pull(i);",
      "    }",
      "    void upd(int lo, int hi, T inc, int p = 1, int L = 0, int R = N - 1) {",
      "        push(p, L, R);",
      "        if (lo > R || L > hi) return;",
      "        if (lo <= L && R <= hi) {",
      "            lazy[p] = inc;",
      "            push(p, L, R);",
      "            return;",
      "        }",
      "        int M = (L + R) / 2;",
      "        upd(lo, hi, inc, 2 * p, L, M);",
      "        upd(lo, hi, inc, 2 * p + 1, M + 1, R);",
      "        pull(p);",
      "    }",
      "    T query(int lo, int hi, int p = 1, int L = 0, int R = N - 1) {",
      "        push(p, L, R);",
      "        if (lo > R || L > hi) return ID;",
      "        if (lo <= L && R <= hi) return seg[p];",
      "        int M = (L + R) / 2;",
      "        return cmb(query(lo, hi, 2 * p, L, M), query(lo, hi, 2 * p + 1, M + 1, R));",
      "    }",
      "};"
    ]
  }
}
